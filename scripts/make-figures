#!/usr/bin/env python3
'''
Generate accuracy/efficiency plots.
'''
from json import loads
from os import listdir, makedirs
from os.path import basename, splitext

import matplotlib.patches as pch
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns

################################################################################
# Load experiment results.
################################################################################

logs = {}

for log_name in listdir('stats'):
    with open('stats/' + log_name, 'r') as f:
        logs[splitext(log_name)[0]] = loads(f.read())

errs = {name: [1 - net['stats_ts']['acc'] for net in log]
        for name, log in logs.items()}
mocs = {name: [net['stats_ts']['moc'] for net in log]
        for name, log in logs.items()}

################################################################################
# Ensure that the output directory exists.
################################################################################

makedirs('figures', exist_ok=True)

################################################################################
# Generate accuracy/efficiency plots.
################################################################################

def make_acc_eff_plot(dst, src):
    plt.figure(figsize=(6, 4))
    plt.xlabel('Mean Op Count')
    plt.ylabel('Error Rate')
    for log_name, label in src:
        plt.plot(mocs[log_name], errs[log_name], label=label)
    plt.ylim(0, 0.2)
    plt.legend()
    plt.tight_layout()
    plt.savefig('figures/' + dst)

make_acc_eff_plot('acc-eff.pdf', [
    ('sr-chains', 'Static Routing'),
    ('ds-chains', 'Decision Smoothing Chains'),
    ('cr-chains', 'Cost Regression Chains'),
    ('ds-trees', 'Decision Smoothing Trees')])

################################################################################
# Generate node-link diagrams.
################################################################################

cls_labels = ['Airplane', 'Automobile', 'Bird', 'Cat', 'Deer',
              'Dog', 'Frog', 'Horse', 'Ship', 'Truck']

def nld_bounds(ℓ, x, y, r):
    x0 = x; x1 = x
    y0 = y; y1 = y
    sinks = ℓ['sinks'][1:]
    for i, s in enumerate(sinks):
        a = ((i + 1) / (len(sinks) + 1) - 0.5) * np.pi
        x_s = x + np.cos(a)
        y_s = y + r * np.sin(a)
        x2, x3, y2, y3 = nld_bounds(s, x_s, y_s, r / len(sinks))
        x0 = min(x0, x2); x1 = max(x1, x3)
        y0 = min(y0, y2); y1 = max(y1, y3)
    return x0, x1, y0, y1

def draw_acc_nld(ℓ, x, y, r):
    p_cor = ℓ['sinks'][0]['stats_ts']['p_cor']
    p_inc = ℓ['sinks'][0]['stats_ts']['p_inc']
    p_tot = p_cor + p_inc
    sinks = ℓ['sinks'][1:]
    if p_tot > 0.005:
        plt.pie([p_cor / p_tot, p_inc / p_tot],
                center=(x, y), startangle=90,
                radius=(np.sqrt(p_tot) / 2),
                colors=[sns.color_palette()[0],
                        sns.color_palette()[2]])
    else:
        plt.pie([1], center=(x, y),
                radius=(np.sqrt(0.005) / 2),
                colors=['k'])
    for i, s in enumerate(sinks):
        a = ((i + 1) / (len(sinks) + 1) - 0.5) * np.pi
        x_s = x + np.cos(a)
        y_s = y + r * np.sin(a)
        plt.plot([x, x_s], [y, y_s], 'k', linewidth=2, zorder=-1)
        draw_acc_nld(s, x_s, y_s, r / len(sinks))

def draw_cls_nld(ℓ, x, y, r):
    p_cor = ℓ['sinks'][0]['stats_ts']['p_cor_by_cls']
    p_inc = ℓ['sinks'][0]['stats_ts']['p_inc_by_cls']
    p_cls = list(map(sum, zip(p_cor, p_inc)))
    p_tot = sum(p_cls)
    sinks = ℓ['sinks'][1:]
    if p_tot > 0.005:
        plt.pie([p / p_tot for p in p_cls],
                center=(x, y), startangle=90,
                radius=(np.sqrt(p_tot) / 2),
                colors=sns.color_palette('hls', len(p_cls)))
    else:
        plt.pie([1], center=(x, y),
                radius=(np.sqrt(0.005) / 2),
                colors=['k'])
    for i, s in enumerate(sinks):
        a = ((i + 1) / (len(sinks) + 1) - 0.5) * np.pi
        x_s = x + np.cos(a)
        y_s = y + r * np.sin(a)
        plt.plot([x, x_s], [y, y_s], 'k', linewidth=2, zorder=-1)
        draw_cls_nld(s, x_s, y_s, r / len(sinks))

def make_chain_acc_nld(dst, log_name):
    plt.figure()
    n_nets = len(logs[log_name])
    max_depth = nld_bounds(logs[log_name][0]['root'], 0, 0, 1)[1]
    for i, net in enumerate(logs[log_name]):
        draw_acc_nld(net['root'], 0, i, 1)
    plt.arrow(0.4 * max_depth, -0.6, 0.2 * max_depth, 0, fc='#b0b0b0',
              ec='#b0b0b0', linewidth=3, head_width=0.075)
    plt.arrow(-0.6, 0.2 * (n_nets - 1), 0, 0.6 * (n_nets - 1), fc='#b0b0b0',
              ec='#b0b0b0', linewidth=3, head_width=0.075)
    plt.ylabel('Cost of Computation', fontsize='large', color='#909090')
    plt.xlabel('Layer Index', fontsize='large', color='#909090')
    plt.xlim(-0.7, max_depth + 0.7)
    plt.ylim(-0.7, n_nets - 0.3)
    plt.figlegend([
        pch.Patch(color=sns.color_palette()[0]),
        pch.Patch(color=sns.color_palette()[2])],
        ['Correct Labels', 'Incorrect Labels'],
        'lower right', fontsize='medium')
    plt.gca().set_aspect('equal')
    plt.gcf().set_size_inches(max_depth + 2, n_nets + 2)
    plt.tight_layout()
    plt.savefig('figures/' + dst)

def make_chain_cls_nld(dst, log_name):
    plt.figure()
    n_nets = len(logs[log_name])
    max_depth = nld_bounds(logs[log_name][0]['root'], 0, 0, 1)[1]
    for i, net in enumerate(logs[log_name]):
        draw_cls_nld(net['root'], 0, i, 1)
    plt.arrow(0.4 * max_depth, -0.6, 0.2 * max_depth, 0, fc='#b0b0b0',
              ec='#b0b0b0', linewidth=3, head_width=0.075)
    plt.arrow(-0.6, 0.2 * (n_nets - 1), 0, 0.6 * (n_nets - 1), fc='#b0b0b0',
              ec='#b0b0b0', linewidth=3, head_width=0.075)
    plt.ylabel('Cost of Computation', fontsize='large', color='#909090')
    plt.xlabel('Layer Index', fontsize='large', color='#909090')
    plt.xlim(-0.7, max_depth + 0.7)
    plt.ylim(-0.7, n_nets - 0.3)
    plt.figlegend(
        [pch.Patch(color=c) for c in sns.color_palette('hls', 10)],
        cls_labels, 'lower right', ncol=5, columnspacing=1, fontsize='small')
    plt.gca().set_aspect('equal')
    plt.gcf().set_size_inches(max_depth + 2, n_nets + 2)
    plt.tight_layout()
    plt.savefig('figures/' + dst)

def make_tree_acc_nld(dst, log_name, i):
    plt.figure()
    net = logs[log_name][i]
    draw_acc_nld(net['root'], 0, 0, 2)
    x0, x1, y0, y1 = nld_bounds(net['root'], 0, 0, 2)
    plt.arrow(0.35 * x1, y0 - 0.33, 0.3 * x1, 0, fc='#b0b0b0',
              ec='#b0b0b0', linewidth=3, head_width=0.075)
    plt.xlabel('Dataflow', fontsize='large', color='#909090')
    plt.xlim(x0 - 0.4, x1 + 0.4)
    plt.ylim(y0 - 0.4, y1 + 0.4)
    plt.figlegend([
        pch.Patch(color=sns.color_palette()[0]),
        pch.Patch(color=sns.color_palette()[2])],
        ['Correct Labels', 'Incorrect Labels'],
        'lower right', fontsize='small')
    plt.gca().set_aspect('equal')
    plt.gcf().set_size_inches(x1 - x0 + 2, y1 - y0 + 2)
    plt.tight_layout()
    plt.savefig('figures/' + dst)

def make_tree_cls_nld(dst, log_name, i):
    plt.figure()
    net = logs[log_name][i]
    draw_cls_nld(net['root'], 0, 0, 2)
    x0, x1, y0, y1 = nld_bounds(net['root'], 0, 0, 2)
    plt.arrow(0.35 * x1, y0 - 0.33, 0.3 * x1, 0, fc='#b0b0b0',
              ec='#b0b0b0', linewidth=3, head_width=0.075)
    plt.xlabel('Dataflow', fontsize='large', color='#909090')
    plt.xlim(x0 - 0.4, x1 + 0.4)
    plt.ylim(y0 - 0.4, y1 + 0.4)
    plt.figlegend(
        [pch.Patch(color=c) for c in sns.color_palette('hls', 10)],
        cls_labels, 'upper left', fontsize='small')
    plt.gca().set_aspect('equal')
    plt.gcf().set_size_inches(x1 - x0 + 2, y1 - y0 + 2)
    plt.tight_layout()
    plt.savefig('figures/' + dst)

make_chain_acc_nld('acc-nld-ds-chains.pdf', 'ds-chains')
make_chain_acc_nld('acc-nld-cr-chains.pdf', 'cr-chains')
make_chain_cls_nld('cls-nld-ds-chains.pdf', 'ds-chains')
make_chain_cls_nld('cls-nld-cr-chains.pdf', 'cr-chains')

for i in range(len(logs['ds-trees'])):
    make_tree_acc_nld('acc-nld-ds-trees-%i.pdf' % i, 'ds-trees', i)
    make_tree_cls_nld('cls-nld-ds-trees-%i.pdf' % i, 'ds-trees', i)
for i in range(len(logs['cr-trees'])):
    make_tree_acc_nld('acc-nld-cr-trees-%i.pdf' % i, 'cr-trees', i)
    make_tree_cls_nld('cls-nld-cr-trees-%i.pdf' % i, 'cr-trees', i)
