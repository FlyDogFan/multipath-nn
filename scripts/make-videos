#!/usr/bin/env python3
'''
Generate accuracy/efficiency plots.
'''
from glob import glob
from os import listdir, makedirs
from os.path import basename, splitext

import matplotlib as mpl
mpl.use('Agg')

import matplotlib as mpl
import matplotlib.patches as pch
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns

################################################################################
# Generate node-link diagrams.
################################################################################

cls_labels = ['0', '1', '2', '3',
              'Airplane', 'Automobile', 'Deer', 'Horse']

def nld_bounds(ℓ, x, y, r):
    x0 = x; x1 = x
    y0 = y; y1 = y
    sinks = ℓ['sinks'][1:]
    for i, s in enumerate(sinks):
        a = ((i + 1) / (len(sinks) + 1) - 0.5) * np.pi
        x_s = x + np.cos(a)
        y_s = y + r * np.sin(a)
        x2, x3, y2, y3 = nld_bounds(s, x_s, y_s, r / len(sinks))
        x0 = min(x0, x2); x1 = max(x1, x3)
        y0 = min(y0, y2); y1 = max(y1, y3)
    return x0, x1, y0, y1

def draw_acc_nld(ℓ, x, y, r):
    p_cor = ℓ['sinks'][0]['stats_ts']['p_cor']
    p_inc = ℓ['sinks'][0]['stats_ts']['p_inc']
    p_tot = p_cor + p_inc
    sinks = ℓ['sinks'][1:]
    if p_tot > 0.005:
        plt.pie([p_cor / p_tot, p_inc / p_tot],
                center=(x, y), startangle=90,
                radius=(np.sqrt(p_tot) / 2),
                colors=[sns.color_palette()[0],
                        sns.color_palette()[2]])
    else:
        plt.pie([1], center=(x, y),
                radius=(np.sqrt(0.005) / 2),
                colors=['k'])
    for i, s in enumerate(sinks):
        a = ((i + 1) / (len(sinks) + 1) - 0.5) * np.pi
        x_s = x + np.cos(a)
        y_s = y + r * np.sin(a)
        plt.plot([x, x_s], [y, y_s], 'k', linewidth=2, zorder=-1)
        draw_acc_nld(s, x_s, y_s, r / len(sinks))

def draw_cls_nld(ℓ, x, y, r):
    p_cor = ℓ['sinks'][0]['stats_ts']['p_cor_by_cls']
    p_inc = ℓ['sinks'][0]['stats_ts']['p_inc_by_cls']
    p_cls = list(map(sum, zip(p_cor, p_inc)))
    p_tot = sum(p_cls)
    sinks = ℓ['sinks'][1:]
    if p_tot > 0.005:
        plt.pie([p / p_tot for p in p_cls],
                center=(x, y), startangle=90,
                radius=(np.sqrt(p_tot) / 2),
                colors=sns.color_palette('hls', len(p_cls)))
    else:
        plt.pie([1], center=(x, y),
                radius=(np.sqrt(0.005) / 2),
                colors=['k'])
    for i, s in enumerate(sinks):
        a = ((i + 1) / (len(sinks) + 1) - 0.5) * np.pi
        x_s = x + np.cos(a)
        y_s = y + r * np.sin(a)
        plt.plot([x, x_s], [y, y_s], 'k', linewidth=2, zorder=-1)
        draw_cls_nld(s, x_s, y_s, r / len(sinks))

def make_chain_acc_nld(dst, logs):
    plt.figure()
    n_nets = len(logs)
    max_depth = nld_bounds(logs[0]['root']['sinks'][0], 0, 0, 1)[1]
    for i, net in enumerate(logs):
        draw_acc_nld(net['root']['sinks'][0], 0, i, 1)
    plt.arrow(0.4 * max_depth, -0.6, 0.2 * max_depth, 0, fc='#909090',
              ec='#909090', linewidth=3, head_width=0.075)
    plt.arrow(-0.6, 0.2 * (n_nets - 1), 0, 0.6 * (n_nets - 1), fc='#909090',
              ec='#909090', linewidth=3, head_width=0.075)
    plt.ylabel('Cost of Computation', fontsize='large', color='#606060')
    plt.xlabel('Layer Index', fontsize='large', color='#606060')
    plt.xlim(-0.7, max_depth + 0.7)
    plt.ylim(-0.7, n_nets - 0.3)
    plt.figlegend([
        pch.Patch(color=sns.color_palette()[0]),
        pch.Patch(color=sns.color_palette()[2])],
        ['Correct Labels', 'Incorrect Labels'],
        'lower right', fontsize='small')
    plt.gca().set_aspect('equal')
    plt.gcf().set_size_inches(max_depth + 2, n_nets + 2)
    plt.tight_layout()
    plt.savefig(dst, dpi=200)

def make_chain_cls_nld(dst, logs):
    plt.figure()
    n_nets = len(logs)
    max_depth = nld_bounds(logs[0]['root']['sinks'][0], 0, 0, 1)[1]
    for i, net in enumerate(logs):
        draw_cls_nld(net['root']['sinks'][0], 0, i, 1)
    plt.arrow(0.4 * max_depth, -0.6, 0.2 * max_depth, 0, fc='#909090',
              ec='#909090', linewidth=3, head_width=0.075)
    plt.arrow(-0.6, 0.2 * (n_nets - 1), 0, 0.6 * (n_nets - 1), fc='#909090',
              ec='#909090', linewidth=3, head_width=0.075)
    plt.ylabel('Cost of Computation', fontsize='large', color='#606060')
    plt.xlabel('Layer Index', fontsize='large', color='#606060')
    plt.xlim(-0.7, max_depth + 0.7)
    plt.ylim(-0.7, n_nets - 0.3)
    plt.figlegend(
        [pch.Patch(color=c) for c in sns.color_palette('hls', 8)],
        cls_labels, 'lower right', ncol=4, columnspacing=1,
        fontsize='small')
    plt.gca().set_aspect('equal')
    plt.gcf().set_size_inches(max_depth + 2, n_nets + 2)
    plt.tight_layout()
    plt.savefig(dst, dpi=200)

makedirs('figures/cr-chains-cls', exist_ok=True)
makedirs('figures/cr-chains-acc', exist_ok=True)

for t in range(1, 61):
    path_template = 'stats/cr-chains_snapshots/%.4i-epoch%.8i.npy'
    make_chain_acc_nld('figures/cr-chains-acc/%.4i.png' % t, [
        np.load(path_template % (i, (1000 * t)))[()]
        for i in range(8)])
    make_chain_cls_nld('figures/cr-chains-cls/%.4i.png' % t, [
        np.load(path_template % (i, (1000 * t)))[()]
        for i in range(8)])
