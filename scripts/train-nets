#!/usr/bin/env python3
'''
Train statically- or dynamically-routed networks.
'''
from argparse import ArgumentParser
from os import makedirs
from os.path import dirname
from random import shuffle

import numpy as np
import tensorflow as tf

from exp.dr_cifar import (
    batch_size, exp_specs, logging_period, n_epochs,
    read_dataset, t_anneal, w_cls, λ_lrn_0)
from lib.desc import net_desc, render_net_desc

################################################################################
# Load the dataset.
################################################################################

dataset = read_dataset()

################################################################################
# Define network statistics.
################################################################################

def p_cor(net, ℓ):
    y_sup = tf.matmul(net.y, w_cls)
    δ_cor = tf.equal(tf.argmax(ℓ.x, 1), tf.argmax(y_sup, 1))
    return ℓ.p_ev * tf.to_float(δ_cor)

def p_inc(net, ℓ):
    y_sup = tf.matmul(net.y, w_cls)
    δ_inc = tf.not_equal(tf.argmax(ℓ.x, 1), tf.argmax(y_sup, 1))
    return ℓ.p_ev * tf.to_float(δ_inc)

def acc_and_moc(net):
    return {(net, 'acc'): sum(p_cor(net, ℓ) for ℓ in net.leaves),
            (net, 'moc'): sum(ℓ.p_ev * ℓ.n_ops for ℓ in net.layers),
            **{(ℓ, 'p_cor'): p_cor(net, ℓ) for ℓ in net.leaves},
            **{(ℓ, 'p_inc'): p_inc(net, ℓ) for ℓ in net.leaves}}

################################################################################
# Define a training function.
################################################################################

def train(dst, net, validate):
    net_state = acc_and_moc(net)
    for t in range(n_epochs):
        set_tr = [('tr', b) for b in dataset.training_batches(batch_size)]
        set_vl = [('vl', b) for b in dataset.validation_batches(batch_size)]
        batches = set_tr + set_vl
        shuffle(batches)
        for mode, (x0, y) in batches:
            op = net.validate if validate and mode == 'vl' else net.train
            op(x0, y, {'λ_lrn': λ_lrn_0 / 2**(t / t_anneal)})
        if (t + 1) % logging_period == 0:
            print(render_net_desc(
                net_desc(net, dataset, {}, net_state),
                '%s — Epoch %i' % (dst, t + 1)))
    makedirs(dirname(dst), exist_ok=True)
    net.write(dst)

################################################################################
# Parse command-line arguments.
################################################################################

parser = ArgumentParser(description=__doc__)
parser.add_argument('target', help='the type of network to train',
                    choices=exp_specs.keys())

args = parser.parse_args()

################################################################################
# Train networks.
################################################################################

for i, (net_constr, validate) in enumerate(exp_specs[args.target]):
    with tf.Graph().as_default():
        train('nets/%s/%i' % (args.target, i), net_constr(), validate)
