#!/usr/bin/env python3
'''
Train statically- or dynamically-routed networks.
'''
from argparse import ArgumentParser
from os import makedirs
from os.path import dirname
from random import shuffle

import numpy as np
import tensorflow as tf

from exp.dr_cifar import (
    batch_size, exp_specs, logging_period,
    n_epochs, t_anneal, λ_lrn_0)
from lib.desc import net_desc, render_net_desc
from lib.serdes import write_net

################################################################################
# Define network statistics.
################################################################################

def state_tensors(net):
    return {(net, 'acc'): sum(ℓ.p_ev * ℓ.δ_cor for ℓ in net.leaves),
            (net, 'moc'): sum(ℓ.p_ev * ℓ.n_ops for ℓ in net.layers),
            **{(ℓ, 'p_cor'): ℓ.p_ev * ℓ.δ_cor for ℓ in net.leaves},
            **{(ℓ, 'p_inc'): ℓ.p_ev * (1 - ℓ.δ_cor) for ℓ in net.leaves}}

################################################################################
# Define a training function.
################################################################################

def train(dst, dataset, net):
    net_state = state_tensors(net)
    for t in range(n_epochs):
        set_tr = [('tr', b) for b in dataset.training_batches(batch_size)]
        set_vl = [('vl', b) for b in dataset.validation_batches(batch_size)]
        batches = set_tr + set_vl
        shuffle(batches)
        for mode, (x0, y) in batches:
            op = net.validate if mode == 'vl' else net.train
            op.run({net.x0: x0, net.y: y, net.mode: mode,
                    net.λ_lrn: λ_lrn_0 / 2**(t / t_anneal)})
        if (t + 1) % logging_period == 0:
            print(render_net_desc(
                net_desc(net, dataset, {}, net_state),
                '%s — Epoch %i' % (dst, t + 1)))
    makedirs(dirname(dst), exist_ok=True)
    write_net(dst, net)

################################################################################
# Parse command-line arguments.
################################################################################

parser = ArgumentParser(description=__doc__)
parser.add_argument('target', help='the type of network to train',
                    choices=exp_specs.keys())

args = parser.parse_args()

################################################################################
# Train networks.
################################################################################

dataset = exp_specs[args.target].dataset()
for i, net_constr in enumerate(exp_specs[args.target].nets):
    with tf.Graph().as_default():
        sess = tf.Session()
        with sess.as_default():
            net = net_constr()
            tf.initialize_all_variables().run()
            train('nets/%s/net%i.npy' % (args.target, i), dataset, net)
